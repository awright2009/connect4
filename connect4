{
  "cells": [
    {
      "cell_type": "markdown",
      "source": [
        "# Code from environment.py"
      ],
      "metadata": {
        "id": "qh0Y-Hf72bY0"
      }
    },
    {
      "cell_type": "code",
      "source": [
        "\n",
        "import math\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "\n",
        "from IPython.display import clear_output\n",
        "\n",
        "import time\n",
        "from timeit import default_timer as timer\n",
        "\n",
        "from scipy.signal import convolve2d\n",
        "\n",
        "def visualize(board):\n",
        "    plt.axes()\n",
        "    rectangle = plt.Rectangle(\n",
        "        (-0.5, len(board)*-1+0.5), len(board[0]), len(board), fc='blue')\n",
        "    circles = []\n",
        "    for i, row in enumerate(board):\n",
        "        for j, val in enumerate(row):\n",
        "            color = 'white' if val == 0 else 'red' if val == 1 else 'yellow'\n",
        "            circles.append(plt.Circle((j, i*-1), 0.4, fc=color))\n",
        "\n",
        "    plt.gca().add_patch(rectangle)\n",
        "    for circle in circles:\n",
        "        plt.gca().add_patch(circle)\n",
        "\n",
        "    plt.axis('scaled')\n",
        "    plt.show()\n",
        "\n",
        "\n",
        "class HelperFunctions:\n",
        "    @staticmethod\n",
        "    def place(choice: int, board, player: int):\n",
        "        board = board.copy()\n",
        "\n",
        "        if (board[0, choice] != 0):\n",
        "            print(f\"invalid Move! Player {player} loses its turn!\")\n",
        "            return board\n",
        "\n",
        "        row = board.shape[0] - 1\n",
        "        while (board[row, choice] != 0):\n",
        "            row -= 1\n",
        "\n",
        "        board[row, choice] = player\n",
        "        return board\n",
        "\n",
        "    @staticmethod\n",
        "    def get_valid_moves(board):\n",
        "        return np.where(board[0]==0)[0].tolist()\n",
        "\n",
        "    @staticmethod\n",
        "    def check_win(board):\n",
        "        # check for win/loss\n",
        "        horizontal_kernel = np.array([[1, 1, 1, 1]])\n",
        "        vertical_kernel = np.transpose(horizontal_kernel)\n",
        "        diag1_kernel = np.eye(4, dtype=np.uint8)\n",
        "        diag2_kernel = np.fliplr(diag1_kernel)\n",
        "        detection_kernels = [horizontal_kernel,\n",
        "                             vertical_kernel, diag1_kernel, diag2_kernel]\n",
        "        for kernel in detection_kernels:\n",
        "\n",
        "            a = convolve2d(board, kernel, mode='valid')\n",
        "            if ((a == 4).any()):\n",
        "                return 1\n",
        "            if ((a == -4).any()):\n",
        "                return -1\n",
        "\n",
        "        # check for draw\n",
        "        if (len(HelperFunctions.get_valid_moves(board)) == 0):\n",
        "            return 0\n",
        "\n",
        "        return None\n",
        "\n",
        "    @staticmethod\n",
        "    def time_function(theFunc, *args):\n",
        "        start = timer()\n",
        "        theFunc(*args)\n",
        "        print(f\"{theFunc.__name__}: {(timer() - start) * 1000} ms\")\n",
        "\n",
        "    @staticmethod\n",
        "    def calc_utility(player, board):\n",
        "        winner = HelperFunctions.check_win(board)\n",
        "\n",
        "        if (winner == None):\n",
        "            raise Exception(\"Tried to calculate the utility of non-terminal state\")\n",
        "\n",
        "        if winner == 0:\n",
        "            return 0\n",
        "        if winner == player:\n",
        "            return 1\n",
        "        else:\n",
        "            return -1\n",
        "\n",
        "\n",
        "def empty_board(shape=(6, 7)):\n",
        "    return np.full(shape=shape, fill_value=0)\n",
        "\n",
        "\n",
        "def truly_dynamic_environment(players, size=(6, 7), visual=False, board=None):\n",
        "    result = {}\n",
        "    if board is None:\n",
        "        board = empty_board(shape=size)\n",
        "    turn_num = 0\n",
        "    result['algo_info'] = {\n",
        "        players[0]['name']: {'time': []},\n",
        "        players[1]['name']: {'time': []}\n",
        "    }\n",
        "    result['algo_info']\n",
        "    past_boards = []\n",
        "    # While there is not a winner yet (0 does not mean draw in this case, it means non terminal state)\n",
        "    while (HelperFunctions.check_win(board) == None):\n",
        "        player_turn = turn_num % 2\n",
        "\n",
        "        start = timer()\n",
        "\n",
        "        # pass a copy of the board so the agent cannot cheat by changing the board\n",
        "        choice = players[player_turn]['algo'](\n",
        "            board.copy(), players[player_turn]['player'], **players[player_turn]['args'])\n",
        "        end = timer()\n",
        "\n",
        "        board = HelperFunctions.place(\n",
        "            choice, board, player=players[player_turn]['player'])\n",
        "        if visual:\n",
        "            visualize(board)\n",
        "            clear_output(wait=True)\n",
        "        result['algo_info'][players[player_turn]['name']\n",
        "                            ]['time'].append((end - start) * 1000)\n",
        "        past_boards.append(board)\n",
        "        turn_num += 1\n",
        "    result['winner'] = HelperFunctions.check_win(board)\n",
        "    result['turns_taken'] = turn_num\n",
        "    for name in result['algo_info']:\n",
        "        print(\n",
        "            f\"{name} took a total of {round(np.sum(result['algo_info'][name]['time'])/ 1000,3)} seconds\")\n",
        "\n",
        "    print(\n",
        "        f\"The winner is {players[(result['winner']-1)//-2]['name']} ({result['winner']})\")\n",
        "    print(f\"Turns Taken: {turn_num}\")\n",
        "\n",
        "    return result, board, past_boards\n",
        "\n",
        "\n",
        "def replay(all_boards, sleep_time: int = 1):\n",
        "    for board in all_boards:\n",
        "        visualize(board)\n",
        "        time.sleep(sleep_time)\n",
        "        clear_output(wait=True)\n",
        "\n",
        "\n",
        "# print(__name__)\n",
        "if __name__ == \"__main__\":\n",
        "\n",
        "    board = [\n",
        "        [-1,  0, -1, -1,  0,  0,  0],\n",
        "        [1,  0, -1,  1,  0,  0,  0,],\n",
        "        [1,  0, -1, -1,  1,  0,  0,],\n",
        "        [1,  0,  1,  1, -1,  0,  0],\n",
        "        [-1,  0, -1,  1,  1, 0,  0],\n",
        "        [-1,  1,  1,  1, -1,  0,  0]\n",
        "\n",
        "    ]\n",
        "\n",
        "    visualize(board)\n"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 430
        },
        "id": "LDaGtoqM2QZK",
        "outputId": "3ef72076-ebe1-4356-f5d4-988ca96673b0"
      },
      "execution_count": 1,
      "outputs": [
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 640x480 with 1 Axes>"
            ],
            "image/png": "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\n"
          },
          "metadata": {}
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "zHxP5gbX1-qP"
      },
      "source": [
        "# Example of how to use the environment"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {
        "id": "UgMhreIi1-qP"
      },
      "outputs": [],
      "source": [
        "!pip install -q matplotlib numpy scipy\n",
        "\n",
        "#from environment import truly_dynamic_environment, replay, visualize\n",
        "import numpy as np"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "TSQM4HaL1-qP"
      },
      "source": [
        "Define agent functions. One example used a simple function and the second uses a class which should be used for model-based agents."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 3,
      "metadata": {
        "id": "koBbeC8f1-qP"
      },
      "outputs": [],
      "source": [
        "# example as a function\n",
        "def act_random(board, player):\n",
        "    \"\"\"A random Connect-4 agent function.\"\"\"\n",
        "    return np.random.choice(np.where(board[0]==0)[0])\n",
        "\n",
        "\n",
        "import pandas as pd\n",
        "import math\n",
        "import copy\n",
        "import random\n",
        "\n",
        "DEBUG = 0\n",
        "\n",
        "# Alexander Wright agent\n",
        "class AwrightAgent:\n",
        "    def __init__(self, name = \"Agent\"):\n",
        "        self.name = name\n",
        "        self.move_count = 0\n",
        "        self.last_x = 0\n",
        "        self.last_y = 0\n",
        "\n",
        "    def act(self, board, player):\n",
        "        self.move_count += 1\n",
        "        if self.move_count <= 2:\n",
        "          return 3\n",
        "        max_int = 2147549183\n",
        "\n",
        "\n",
        "        # these are still very slow\n",
        "        #score, move = self.minimax_correct(copy.deepcopy(board), 100000000000000, -max_int, max_int, player, player, False)\n",
        "        #score, move = self.minimax_correct_no_heuristic(copy.deepcopy(board), 100000000000000, -max_int, max_int, player, player, False)\n",
        "        #score, move = self.minimax_correct_best_move(copy.deepcopy(board), 100000000000000, -max_int, max_int, player, player, False)\n",
        "\n",
        "        move = self.UCT_depth1(board, 100000, player)\n",
        "        return move\n",
        "\n",
        "\n",
        "    # Return available moves given a board\n",
        "    def actions(self, board):\n",
        "        available = []\n",
        "\n",
        "        num_col = len(board[0])\n",
        "        num_row = len(board)\n",
        "\n",
        "        for x in range(num_col):\n",
        "            for y in range(num_row - 1, -1, -1):\n",
        "                if board[y][x] == 0:\n",
        "                    available.append(x)\n",
        "                    break\n",
        "\n",
        "        return available\n",
        "\n",
        "    # Makes a move given a board, move (0-6 column) and player (-1,1)\n",
        "    def make_move(self, board, move, player):\n",
        "        # we loop from the botton of the board up until we find a space\n",
        "        # range(start, stop, step) -- start at end, stop past zero, decrement\n",
        "        for y in range(len(board) - 1, -1, -1):\n",
        "            if board[y][move] == 0:\n",
        "                board[y][move] = player\n",
        "                self.last_x = move\n",
        "                self.last_y = y\n",
        "                break\n",
        "\n",
        "        # result wants a board returned, so we modify the board and return a copy of it\n",
        "        new_board = copy.deepcopy(board)\n",
        "        return new_board\n",
        "\n",
        "    # Check for a consecutive set of pieces starting from (x,y) in direction (dx,dy)\n",
        "    def check_consecutive(self, board, y, x, dy, dx):\n",
        "        player = board[y][x]\n",
        "        num_col = len(board[0])\n",
        "        num_row = len(board)\n",
        "\n",
        "\n",
        "        # player should not be empty space\n",
        "        if player == 0:\n",
        "            return False\n",
        "\n",
        "        # checking for three additional neighboring pieces: 1, 2, 3\n",
        "        for i in range(1, 4):\n",
        "            # new posiiton is initial plus delta, we skip zero as we already know we have the first spot\n",
        "            ny = y + dy * i\n",
        "            nx = x + dx * i\n",
        "\n",
        "            # if out of bounds, or the color changes, then we didn't win\n",
        "            if ny < 0 or ny >= num_row or nx < 0 or nx >= num_col or board[ny][nx] != player:\n",
        "                return False\n",
        "\n",
        "        return True\n",
        "\n",
        "\n",
        "    # Check if someone has won given a board by looping through each position and checking each direction for a winner\n",
        "    def check_winner(self, board):\n",
        "        num_col = len(board[0])\n",
        "        num_row = len(board)\n",
        "\n",
        "        # For every position on the board\n",
        "        for y in range(num_row):\n",
        "            for x in range(num_col):\n",
        "\n",
        "                # if the position is not empty\n",
        "                if board[y][x] != 0:\n",
        "\n",
        "                    # Check for a win by moving right\n",
        "                    if self.check_consecutive(board, y, x, 0, 1):\n",
        "                        return board[y][x]\n",
        "\n",
        "                    # Check for a win by moving left\n",
        "                    if self.check_consecutive(board, y, x, 0, -1):\n",
        "                        return board[y][x]\n",
        "\n",
        "                    # Check for a win by moving up\n",
        "                    if self.check_consecutive(board, y, x, 1, 0):\n",
        "                        return board[y][x]\n",
        "\n",
        "                    # Check for a win by moving down\n",
        "                    if self.check_consecutive(board, y, x, -1, 0):\n",
        "                        return board[y][x]\n",
        "\n",
        "                    # Check for a win by moving up right\n",
        "                    if self.check_consecutive(board, y, x, 1, 1):\n",
        "                        return board[y][x]\n",
        "\n",
        "                    # Check for a win by moving down right\n",
        "                    if self.check_consecutive(board, y, x, 1, -1):\n",
        "                        return board[y][x]\n",
        "\n",
        "                    # Check for a win by moving down left\n",
        "                    if self.check_consecutive(board, y, x, -1, -1):\n",
        "                        return board[y][x]\n",
        "\n",
        "                    # Check for a win by moving up left\n",
        "                    if self.check_consecutive(board, y, x, -1, 1):\n",
        "                        return board[y][x]\n",
        "\n",
        "\n",
        "\n",
        "        return 0\n",
        "\n",
        "    # Note that the tic tac toe minimax examples do not use a \"score\"\n",
        "    # They just use the win/loss/draw totals\n",
        "    def utility(self, board, player):\n",
        "        winner = self.check_winner(board)\n",
        "        if winner == player:\n",
        "            return 1\n",
        "        elif winner == self.other(player):\n",
        "            return -1\n",
        "        elif self.board_full(board):\n",
        "            return 0\n",
        "        else:\n",
        "            return None\n",
        "\n",
        "    # Given a player (-1,1) return the opposite player (1,-1)\n",
        "    # Used for minimax algorithm\n",
        "    def other(self, player):\n",
        "        if player == 1:\n",
        "          return -1\n",
        "        else:\n",
        "          return 1\n",
        "\n",
        "    # Play a game randomly, then return if we won or lost\n",
        "    def playout(self, state, action, player):\n",
        "        \"\"\"Perform a random playout starting with the given action on the given board\n",
        "        and return the utility of the finished game.\"\"\"\n",
        "        state = self.result(state, player, action)\n",
        "        current_player = self.other(player)\n",
        "\n",
        "        while(True):\n",
        "            # reached terminal state?\n",
        "            u = self.utility(state, player)\n",
        "            if u is not None:\n",
        "              return(u)\n",
        "\n",
        "            # we use a random playout policy\n",
        "            a = np.random.choice(self.actions(state))\n",
        "            state = self.result(state, current_player, a)\n",
        "            #print(state)\n",
        "\n",
        "            # switch between players\n",
        "            current_player = self.other(current_player)\n",
        "\n",
        "    # Plays the game N times randomly, gives win/loss numbers\n",
        "    def playouts(self, board, action, player, N = 100):\n",
        "        \"\"\"Perform N playouts following the given action for the given board.\"\"\"\n",
        "        return [ self.playout(board, action, player) for i in range(N) ]\n",
        "\n",
        "\n",
        "    # Returns best move given N playouts of random moves, where best is the move that caused us to win the most\n",
        "    def pmcs(self, board, N, player):\n",
        "        global DEBUG\n",
        "\n",
        "        available = self.actions(board)\n",
        "        if available == 0:\n",
        "          return None\n",
        "\n",
        "        n = math.floor(N/len(available))\n",
        "        if DEBUG >= 1:\n",
        "          print(f\"Actions: {available} ({N} total playouts = {n} playouts per action)\")\n",
        "\n",
        "\n",
        "        ps = { i : np.mean(self.playouts(board, i, player, N = n)) for i in available }\n",
        "\n",
        "        if DEBUG >= 1:\n",
        "          display(ps)\n",
        "\n",
        "        move = max(ps, key=ps.get)\n",
        "        return move\n",
        "\n",
        "    # Just changed function parameters to match the tic tac toe example (plus debug flags)\n",
        "    def my_playout_compat(self, global_board, action, player, show_final_board, debug):\n",
        "        # player tokens\n",
        "        opponent = -player\n",
        "\n",
        "        if debug:\n",
        "          visualize(global_board)\n",
        "\n",
        "\n",
        "        # play until someone wins or no more moves\n",
        "        while 1:\n",
        "          move1 = action\n",
        "          if debug:\n",
        "            print(\"Player 1 Move \", move1, \" Random\")\n",
        "          global_board = self.make_move(global_board, move1, player)\n",
        "\n",
        "          if debug:\n",
        "            visualize(global_board)\n",
        "            time.sleep(1)\n",
        "\n",
        "          if self.terminal(global_board):\n",
        "            break\n",
        "          #move2 = random_player(global_board, opponent)\n",
        "          temp_board = copy.deepcopy(global_board)\n",
        "          move2 = self.pmcs(temp_board, 1000, player)\n",
        "\n",
        "          if debug:\n",
        "            print(\"Player 2 Move \", move2, \" Random\")\n",
        "          global_board = self.make_move(global_board, move2, opponent)\n",
        "          if debug:\n",
        "            visualize(global_board)\n",
        "            time.sleep(1)\n",
        "          if self.terminal(global_board):\n",
        "            break\n",
        "\n",
        "\n",
        "        winner = self.check_winner(global_board)\n",
        "\n",
        "        if show_final_board:\n",
        "          visualize(global_board)\n",
        "          print(self.get_winner(global_board))\n",
        "\n",
        "        return winner\n",
        "\n",
        "\n",
        "    def terminal(self, board):\n",
        "        winner = self.check_winner(board)\n",
        "        if winner == 1:\n",
        "            return True\n",
        "        elif winner == -1:\n",
        "            return True\n",
        "        elif self.board_full(board):\n",
        "            return True\n",
        "        else:\n",
        "            return False\n",
        "\n",
        "    # Check if the board is full\n",
        "    def board_full(self, board):\n",
        "        for row in board:\n",
        "            # if any position is not filled (zero), then we are not full\n",
        "            if 0 in row:\n",
        "                return False\n",
        "        return True\n",
        "\n",
        "    # returns winner result as a string\n",
        "    def get_winner(self, board):\n",
        "        winner = self.check_winner(board)\n",
        "        if winner == 1:\n",
        "            return \"Player 1 wins\"\n",
        "        elif winner == -1:\n",
        "            return \"Player 2 wins\"\n",
        "        elif self.board_full(board):\n",
        "            return \"Draw\"\n",
        "        else:\n",
        "            return \"No winners yet\"\n",
        "\n",
        "\n",
        "    def UCT_depth1(self, board, N, player):\n",
        "        \"\"\"Upper Confidence bound applied to Trees for limited tree depth of 1.\n",
        "        Simulation budget is N playouts.\"\"\"\n",
        "        global DEBUG\n",
        "\n",
        "        C = math.sqrt(2) # tradeoff constant\n",
        "\n",
        "        # the tree is 1 action deep\n",
        "        acts = self.actions(board)\n",
        "\n",
        "        u = [0] * len(acts) # total utility through actions\n",
        "        n = [0] * len(acts) # number of playouts through actions\n",
        "        n_parent = 0 # total playouts so far (i.e., number of playouts through parent)\n",
        "\n",
        "        # make sure we try each action once\n",
        "        UCB1 = [+math.inf] * len(acts)\n",
        "\n",
        "        for i in range(N):\n",
        "\n",
        "            # Select\n",
        "            action_id = UCB1.index(max(UCB1))\n",
        "\n",
        "            # Expand\n",
        "            # UTC would expand the tree. We keep the tree at depth 1, essentially performing\n",
        "            # Pure Monte Carlo search with an added UCB1 selection policy.\n",
        "\n",
        "            # Simulate\n",
        "            p = self.my_playout_compat(board, acts[action_id], player, False, False)\n",
        "\n",
        "            # Back-Propagate (i.e., update counts and UCB1)\n",
        "            u[action_id] += p\n",
        "            n[action_id] += 1\n",
        "            n_parent += 1\n",
        "\n",
        "            for action_id in range(len(acts)):\n",
        "                if n[action_id] > 0:\n",
        "                    UCB1[action_id] = u[action_id] / n[action_id] + C * math.sqrt(math.log(n_parent) / n[action_id])\n",
        "\n",
        "        # return action with largest number of playouts\n",
        "        action = acts[n.index(max(n))]\n",
        "\n",
        "        if DEBUG >= 1:\n",
        "            print(pd.DataFrame({'action':acts,\n",
        "                                'total utility':u,\n",
        "                                '# of playouts':n,\n",
        "                                'UCB1':UCB1}))\n",
        "            print()\n",
        "            print(f\"Best action: {action}\")\n",
        "\n",
        "\n",
        "        return action\n",
        "\n",
        "\n",
        "\n",
        "    def visualize(self, board):\n",
        "        # make these images smaller (2 inches by 2 inches)\n",
        "        plt.figure(figsize=(2, 2))\n",
        "\n",
        "        plt.axes()\n",
        "        rectangle=plt.Rectangle((-0.5,len(board)*-1+0.5),len(board[0]),len(board),fc='blue')\n",
        "        circles=[]\n",
        "        for i,row in enumerate(board):\n",
        "            for j,val in enumerate(row):\n",
        "                color='white' if val==0 else 'red' if val==1 else 'yellow'\n",
        "                circles.append(plt.Circle((j,i*-1),0.4,fc=color))\n",
        "\n",
        "        plt.gca().add_patch(rectangle)\n",
        "        for circle in circles:\n",
        "            plt.gca().add_patch(circle)\n",
        "\n",
        "        plt.axis('scaled')\n",
        "        plt.show()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    # adds a flag that will use pink and olive instead of red and yellow\n",
        "    def visualize_debug(self, board, fake=False):\n",
        "        plt.axes()\n",
        "        rectangle=plt.Rectangle((-0.5,len(board)*-1+0.5),len(board[0]),len(board),fc='blue')\n",
        "        circles=[]\n",
        "        for i,row in enumerate(board):\n",
        "            for j,val in enumerate(row):\n",
        "\n",
        "                if fake == False:\n",
        "                  color='white' if val==0 else 'red' if val==1 else 'yellow'\n",
        "                else:\n",
        "                  color='white' if val==0 else 'pink' if val==1 else 'olive'\n",
        "                circles.append(plt.Circle((j,i*-1),0.4,fc=color))\n",
        "\n",
        "        plt.gca().add_patch(rectangle)\n",
        "        for circle in circles:\n",
        "            plt.gca().add_patch(circle)\n",
        "\n",
        "        plt.axis('scaled')\n",
        "        plt.show()\n",
        "\n",
        "\n",
        "    # Note this function name gave me some issues as result is a little\n",
        "    #  too common and was used later for a return value causing the\n",
        "    #  next function call to not be defined on a bool\n",
        "    def result(self, board, player, action):\n",
        "      return self.make_move(board, action, player)\n",
        "\n",
        "\n",
        "\n",
        "    # Given a board, give it a \"goodness\" value from perspective of a player\n",
        "    # Goodness directly related to how many consecutive pieces we have\n",
        "    # very similar to how we check for the win condition\n",
        "    def score_position(self, board, y, x, player):\n",
        "        num_col = len(board[0])\n",
        "        num_row = len(board)\n",
        "\n",
        "        score = 0\n",
        "\n",
        "        # Get score by moving right\n",
        "        score += self.score_consecutive(board, y, x, 0, 1, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving left\n",
        "        score += self.score_consecutive(board, y, x, 0, -1, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving up\n",
        "        score += self.score_consecutive(board, y, x, 1, 0, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving down\n",
        "        score += self.score_consecutive(board, y, x, -1, 0, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving up right\n",
        "        score += self.score_consecutive(board, y, x, 1, 1, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving down right\n",
        "        score += self.score_consecutive(board, y, x, 1, -1, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving down left\n",
        "        score += self.score_consecutive(board, y, x, -1, -1, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving up left\n",
        "        score += self.score_consecutive(board, y, x, -1, 1, player, num_row, num_col)\n",
        "\n",
        "        return score\n",
        "\n",
        "    # This is where some subjectivity comes into play\n",
        "    # We give a numerical score for the number of consecutive pieces we have\n",
        "    # given a start position and direction for the given position\n",
        "    # Note this is after a fake/simulated move has been made adding an additional piece\n",
        "    def score_consecutive(self, board, y, x, dy, dx, player, num_row, num_col):\n",
        "        score = 0\n",
        "        player_count = 0\n",
        "        empty_count = 0\n",
        "        opponent_count = 0\n",
        "\n",
        "        num_col = len(board[0])\n",
        "        num_row = len(board)\n",
        "\n",
        "        for i in range(4):\n",
        "            ny = y + dy * i\n",
        "            nx = x + dx * i\n",
        "            if 0 <= ny < num_row and 0 <= nx < num_col:\n",
        "                if board[ny][nx] == player:\n",
        "                    player_count += 1\n",
        "                elif board[ny][nx] == 0:\n",
        "                    empty_count += 1\n",
        "                elif board[ny][nx] == -player:\n",
        "                    opponent_count += 1\n",
        "\n",
        "        if player_count == 4:\n",
        "            score += 100\n",
        "        elif player_count == 3 and empty_count == 1:\n",
        "            score += 10\n",
        "        elif player_count == 2 and empty_count == 2:\n",
        "            score += 5\n",
        "        if opponent_count == 3 and empty_count == 1:\n",
        "            score -= 20\n",
        "\n",
        "        return score\n",
        "\n",
        "\n",
        "    # Note symmetric version just uses a different heuristic\n",
        "    # used for making a move given only the current boards\n",
        "    # state, later used for \"best move first\" logic\n",
        "    def score_position_symmetric(self, board, y, x, player):\n",
        "        num_col = len(board[0])\n",
        "        num_row = len(board)\n",
        "\n",
        "        score = 0\n",
        "\n",
        "        # Get score by moving right\n",
        "        score += self.score_consecutive_symmetric(board, y, x, 0, 1, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving left\n",
        "        score += self.score_consecutive_symmetric(board, y, x, 0, -1, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving up\n",
        "        score += self.score_consecutive_symmetric(board, y, x, 1, 0, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving down\n",
        "        score += self.score_consecutive_symmetric(board, y, x, -1, 0, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving up right\n",
        "        score += self.score_consecutive_symmetric(board, y, x, 1, 1, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving down right\n",
        "        score += self.score_consecutive_symmetric(board, y, x, 1, -1, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving down left\n",
        "        score += self.score_consecutive_symmetric(board, y, x, -1, -1, player, num_row, num_col)\n",
        "\n",
        "        # Get score by moving up left\n",
        "        score += self.score_consecutive_symmetric(board, y, x, -1, 1, player, num_row, num_col)\n",
        "\n",
        "        return score\n",
        "\n",
        "    # This is where some subjectivity comes into play\n",
        "    # We give a numerical score for the number of consecutive pieces we have\n",
        "    # given a start position and direction for the given position\n",
        "    # Note this is after a fake/simulated move has been made adding an additional piece\n",
        "    def score_consecutive_symmetric(self, board, y, x, dy, dx, player, num_row, num_col):\n",
        "        score = 0\n",
        "        player_count = 0\n",
        "        empty_count = 0\n",
        "        opponent_count = 0\n",
        "\n",
        "        num_col = len(board[0])\n",
        "        num_row = len(board)\n",
        "\n",
        "        for i in range(4):\n",
        "            ny = y + dy * i\n",
        "            nx = x + dx * i\n",
        "            if 0 <= ny < num_row and 0 <= nx < num_col:\n",
        "                if board[ny][nx] == player:\n",
        "                    player_count += 1\n",
        "                elif board[ny][nx] == 0:\n",
        "                    empty_count += 1\n",
        "                elif board[ny][nx] == -player:\n",
        "                    opponent_count += 1\n",
        "\n",
        "        if player_count == 4:\n",
        "            score += 45\n",
        "        elif player_count == 3 and empty_count == 1:\n",
        "            score += 35\n",
        "        elif player_count == 2 and empty_count == 2:\n",
        "            score += 25\n",
        "        elif opponent_count == 2 and empty_count == 2:\n",
        "            score += 20\n",
        "        if opponent_count == 3 and empty_count == 1:\n",
        "            score += 40\n",
        "        if opponent_count == 4:\n",
        "            score += 50\n",
        "\n",
        "        return score\n",
        "\n",
        "\n",
        "    # This generates a single score for an entire board\n",
        "    # Essentially just sums the score for your pieces\n",
        "    # and subtracts the opponents score for their pieces\n",
        "    # Ignores free spaces\n",
        "    def score_board(self, board, player):\n",
        "        opponent = -player\n",
        "\n",
        "        winner = self.check_winner(board)\n",
        "        if winner == player:\n",
        "            return 100\n",
        "        elif winner == opponent:\n",
        "            return -100\n",
        "\n",
        "        score = 0\n",
        "        num_col = len(board[0])\n",
        "        num_row = len(board)\n",
        "\n",
        "        # For every position on the board\n",
        "        for y in range(num_row):\n",
        "            for x in range(num_col):\n",
        "\n",
        "                # if the position is ours, score it, if not score the opponent as a\n",
        "                if board[y][x] == player:\n",
        "                  score += self.score_position(board, y, x, player)\n",
        "                elif board[y][x] == opponent:\n",
        "                  score -= self.score_position(board, y, x, opponent)\n",
        "\n",
        "        return score\n",
        "\n",
        "\n",
        "\n",
        "    # So this gives a score to a board and returns it as a matrix of board size\n",
        "    # This ignores taken spaces and just rates free spaces based on how\n",
        "    # good of a move it is\n",
        "    # I use this for picking a move directly without considering \"future moves\"\n",
        "    def score_board_matrix(self, board, player):\n",
        "        opponent = -player\n",
        "\n",
        "\n",
        "        score = copy.deepcopy(board)\n",
        "        num_col = len(board[0])\n",
        "        num_row = len(board)\n",
        "\n",
        "        # For every position on the board\n",
        "        for y in range(num_row):\n",
        "            for x in range(num_col):\n",
        "\n",
        "                # if the position is ours, score it, if not score the opponent as a\n",
        "                if board[y][x] == player:\n",
        "                  score[y][x] = 0\n",
        "                elif board[y][x] == opponent:\n",
        "                  score[y][x] = 0\n",
        "                else:\n",
        "                  score[y][x] = self.score_position_symmetric(board, y, x, player)\n",
        "\n",
        "        return score\n",
        "\n",
        "    # This just select the column with the max score from the above function\n",
        "    def best_move_matrix(self, board):\n",
        "        num_col = len(board[0])\n",
        "        num_row = len(board)\n",
        "\n",
        "        max_score = -999999\n",
        "        max_col = 0\n",
        "\n",
        "        for y in range(num_row):\n",
        "            for x in range(num_col):\n",
        "              if board[y][x] > max_score:\n",
        "                max_score = board[y][x]\n",
        "                max_col = x\n",
        "\n",
        "        return max_col\n",
        "\n",
        "\n",
        "\n",
        "    # We aren't using a class here as everything is stateless, but doing a deep copy to ensure we never modify the original board\n",
        "    def minimax_actually_wins(self, original_board, depth, max_player, player, debug = False):\n",
        "\n",
        "        # recursive depth limit\n",
        "        if depth == 0:\n",
        "          if debug:\n",
        "            print(\"\\tdepth limit reached, no move possible\")\n",
        "          return self.score_board(board, player), None\n",
        "\n",
        "        # we do a lot of deep copies to ensure we dont modify the provided input board\n",
        "        board = copy.deepcopy(original_board)\n",
        "        opponent = -player\n",
        "        available = self.actions(board)\n",
        "        random.shuffle(available)\n",
        "\n",
        "\n",
        "        if debug:\n",
        "          print(\"minimax_actually_wins(board, \", depth, \", \", max_player, \", \", player, \")\")\n",
        "\n",
        "        # Check if the game is over\n",
        "        winner = self.check_winner(board)\n",
        "        if winner == player:\n",
        "            if debug:\n",
        "              print(\"\\tWe already won\")\n",
        "              visualize(board)\n",
        "              print(\"\\tEnd 1\")\n",
        "            return 9999, None\n",
        "        elif winner == opponent:\n",
        "            if debug:\n",
        "              visualize(board)\n",
        "              print(\"\\tThey already won\")\n",
        "              visualize(board)\n",
        "              print(\"\\tEnd 2\")\n",
        "            return -9999, None\n",
        "        elif len(available) == 0:\n",
        "          if debug:\n",
        "            print(\"\\tdraw game, no move possible\")\n",
        "          return 0, None\n",
        "\n",
        "        # Check if we are maxing or min-ing\n",
        "        if max_player == player:\n",
        "            # set a really low value so we always beat it\n",
        "            max_score = -2147549183\n",
        "            max_column = random.choice(available)\n",
        "\n",
        "            for move in available:\n",
        "              new_board = self.make_move(board, move, player)\n",
        "              new_score, new_move = self.minimax_actually_wins(new_board, depth - 1, opponent, player)\n",
        "\n",
        "              # Max\n",
        "              if new_score > max_score:\n",
        "                max_score = new_score\n",
        "                max_column = move\n",
        "\n",
        "            return max_score, max_column\n",
        "        else:\n",
        "            # set a really high value so we always beat it\n",
        "            min_score = 2147549183\n",
        "            min_column = random.choice(available)\n",
        "\n",
        "            for move in available:\n",
        "              new_board = self.make_move(board, move, player)\n",
        "              new_score, new_move = self.minimax_actually_wins(new_board, depth - 1, player, player)\n",
        "\n",
        "              # Min\n",
        "              if new_score < min_score:\n",
        "                min_score = new_score\n",
        "                min_column = move\n",
        "\n",
        "            return min_score, min_column\n",
        "\n",
        "    def minimax_correct(self, original_board, depth, alpha, beta, max_player, player, debug = False):\n",
        "\n",
        "        # recursive depth limit\n",
        "        if depth == 0:\n",
        "          #print(\"\\tdepth limit reached, no move possible\")\n",
        "          return self.score_board(board, player), None\n",
        "\n",
        "        # copy board, get available moves\n",
        "        board = copy.deepcopy(original_board)\n",
        "        opponent = -player\n",
        "        available = self.actions(board)\n",
        "        random.shuffle(available)\n",
        "\n",
        "        # Check if the same is over (win/loss/draw)\n",
        "        winner = self.check_winner(board)\n",
        "        if winner == max_player:\n",
        "            #print(\"\\tWe already won, no move possible\")\n",
        "            return 100, None\n",
        "        elif winner == -max_player:\n",
        "            #print(\"\\tThey already won, no move possible\")\n",
        "            return -100, None\n",
        "        elif len(available) == 0:\n",
        "            #print(\"\\tdraw game, no move possible\")\n",
        "            return 0, None\n",
        "\n",
        "        if max_player == player:\n",
        "            # set a really low value so we always beat it\n",
        "            max_score = -2147549183\n",
        "            max_column = random.choice(available)\n",
        "\n",
        "            for move in available:\n",
        "              # make the move, returns new board\n",
        "              new_board = self.make_move(board, move, player)\n",
        "\n",
        "              if debug:\n",
        "                self.visualize_debug(new_board, True)\n",
        "\n",
        "              # recursive call, simulate the opponents move\n",
        "              new_score, new_move = self.minimax_correct(new_board, depth - 1, alpha, beta, max_player, opponent, debug)\n",
        "\n",
        "              # Max\n",
        "              if new_score > max_score:\n",
        "                max_score = new_score\n",
        "                max_column = move\n",
        "\n",
        "              alpha = max(alpha, max_score)\n",
        "              if beta <= alpha:\n",
        "                  break\n",
        "\n",
        "            return max_score, max_column\n",
        "        else:\n",
        "          # set a really high value so we always beat it\n",
        "            min_score = 2147549183\n",
        "            min_column = random.choice(available)\n",
        "\n",
        "            for move in available:\n",
        "              new_board = self.make_move(board, move, player)\n",
        "\n",
        "              if debug:\n",
        "                self.visualize_debug(new_board, True)\n",
        "\n",
        "              # recursive call, simulate the opponents move\n",
        "              new_score, new_move = self.minimax_correct(new_board, depth - 1, alpha, beta, max_player, opponent, debug)\n",
        "\n",
        "              # Min\n",
        "              if new_score < min_score:\n",
        "                min_score = new_score\n",
        "                min_column = move\n",
        "\n",
        "              beta = min(beta, min_score)\n",
        "              if beta <= alpha:\n",
        "                  break\n",
        "\n",
        "            return min_score, min_column\n",
        "\n",
        "    def minimax_correct_no_heuristic(self, original_board, depth, alpha, beta, max_player, player, debug = False):\n",
        "\n",
        "        # recursive depth limit\n",
        "        if depth == 0:\n",
        "          #print(\"\\tdepth limit reached, no move possible\")\n",
        "          return 0, None\n",
        "\n",
        "        # copy board, get available moves\n",
        "        board = copy.deepcopy(original_board)\n",
        "        opponent = -player\n",
        "        available = self.actions(board)\n",
        "        random.shuffle(available)\n",
        "\n",
        "        # Check if the same is over (win/loss/draw)\n",
        "        winner = self.check_winner(board)\n",
        "        if winner == max_player:\n",
        "            #print(\"\\tWe already won, no move possible\")\n",
        "            return 1, None\n",
        "        elif winner == -max_player:\n",
        "            #print(\"\\tThey already won, no move possible\")\n",
        "            return -1, None\n",
        "        elif len(available) == 0:\n",
        "            #print(\"\\tdraw game, no move possible\")\n",
        "            return 0, None\n",
        "\n",
        "        if max_player == player:\n",
        "            # set a really low value so we always beat it\n",
        "            max_score = -2147549183\n",
        "            max_column = random.choice(available)\n",
        "\n",
        "            for move in available:\n",
        "              # make the move, returns new board\n",
        "              new_board = self.make_move(board, move, player)\n",
        "\n",
        "              if debug:\n",
        "                self.visualize_debug(new_board, True)\n",
        "\n",
        "              # recursive call, simulate the opponents move\n",
        "              new_score, new_move = self.minimax_correct(new_board, depth - 1, alpha, beta, max_player, opponent, debug)\n",
        "\n",
        "              # Max\n",
        "              if new_score > max_score:\n",
        "                max_score = new_score\n",
        "                max_column = move\n",
        "\n",
        "              alpha = max(alpha, max_score)\n",
        "              if beta <= alpha:\n",
        "                  break\n",
        "\n",
        "            return max_score, max_column\n",
        "        else:\n",
        "          # set a really high value so we always beat it\n",
        "            min_score = 2147549183\n",
        "            min_column = random.choice(available)\n",
        "\n",
        "            for move in available:\n",
        "              new_board = self.make_move(board, move, player)\n",
        "\n",
        "              if debug:\n",
        "                self.visualize_debug(new_board, True)\n",
        "\n",
        "              # recursive call, simulate the opponents move\n",
        "              new_score, new_move = self.minimax_correct(new_board, depth - 1, alpha, beta, max_player, opponent, debug)\n",
        "\n",
        "              # Min\n",
        "              if new_score < min_score:\n",
        "                min_score = new_score\n",
        "                min_column = move\n",
        "\n",
        "              beta = min(beta, min_score)\n",
        "              if beta <= alpha:\n",
        "                  break\n",
        "\n",
        "            return min_score, min_column\n",
        "\n",
        "    def minimax_correct_best_move(self, original_board, depth, alpha, beta, max_player, player, debug = False):\n",
        "\n",
        "        # recursive depth limit\n",
        "        if depth == 0:\n",
        "          #print(\"\\tdepth limit reached, no move possible\")\n",
        "          return self.score_board(board, player), None\n",
        "\n",
        "        # copy board, get available moves\n",
        "        board = copy.deepcopy(original_board)\n",
        "        opponent = -player\n",
        "        available =  self.actions(board)\n",
        "        random.shuffle(available)\n",
        "\n",
        "        # Check if the same is over (win/loss/draw)\n",
        "        winner =  self.check_winner(board)\n",
        "        if winner == max_player:\n",
        "            #print(\"\\tWe already won, no move possible\")\n",
        "            return 100, None\n",
        "        elif winner == -max_player:\n",
        "            #print(\"\\tThey already won, no move possible\")\n",
        "            return -100, None\n",
        "        elif len(available) == 0:\n",
        "            #print(\"\\tdraw game, no move possible\")\n",
        "            return 0, None\n",
        "\n",
        "        if max_player == player:\n",
        "            # set a really low value so we always beat it\n",
        "            max_score = -2147549183\n",
        "            max_column = random.choice(available)\n",
        "\n",
        "            # get the best move\n",
        "            mat =  self.score_board_matrix(board, opponent)\n",
        "            move1 =  self.best_move_matrix(mat)\n",
        "\n",
        "            # insert it first\n",
        "            available.insert(0, move1)\n",
        "\n",
        "            new_available = []\n",
        "            # remove duplicates\n",
        "            for move in available:\n",
        "              if move not in new_available:\n",
        "                new_available.append(move)\n",
        "\n",
        "            # remove duplicate from end\n",
        "\n",
        "\n",
        "            for move in new_available:\n",
        "              # make the move, returns new board\n",
        "              new_board =  self.make_move(board, move, player)\n",
        "\n",
        "              if debug:\n",
        "                 self.visualize_debug(new_board, True)\n",
        "\n",
        "              # recursive call, simulate the opponents move\n",
        "              new_score, new_move =  self.minimax_correct(new_board, depth - 1, alpha, beta, max_player, opponent, debug)\n",
        "\n",
        "              # Max\n",
        "              if new_score > max_score:\n",
        "                max_score = new_score\n",
        "                max_column = move\n",
        "\n",
        "              alpha = max(alpha, max_score)\n",
        "              if beta <= alpha:\n",
        "                  break\n",
        "\n",
        "            return max_score, max_column\n",
        "        else:\n",
        "          # set a really high value so we always beat it\n",
        "            min_score = 2147549183\n",
        "            min_column = random.choice(available)\n",
        "\n",
        "\n",
        "            # get the best move\n",
        "            mat = self.score_board_matrix(board, opponent)\n",
        "            move1 = self.best_move_matrix(mat)\n",
        "\n",
        "            # insert it first\n",
        "            available.insert(0, move1)\n",
        "\n",
        "            new_available = []\n",
        "            # remove duplicates\n",
        "            for move in available:\n",
        "              if move not in new_available:\n",
        "                new_available.append(move)\n",
        "\n",
        "            for move in new_available:\n",
        "              new_board = self.make_move(board, move, player)\n",
        "\n",
        "              if debug:\n",
        "                self.visualize_debug(new_board, True)\n",
        "\n",
        "              # recursive call, simulate the opponents move\n",
        "              new_score, new_move = self.minimax_correct(new_board, depth - 1, alpha, beta, max_player, opponent, debug)\n",
        "\n",
        "              # Min\n",
        "              if new_score < min_score:\n",
        "                min_score = new_score\n",
        "                min_column = move\n",
        "\n",
        "              beta = min(beta, min_score)\n",
        "              if beta <= alpha:\n",
        "                  break\n",
        "\n",
        "            return min_score, min_column\n",
        "\n",
        "\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "J5opzfi11-qP"
      },
      "source": [
        "Create an instance of the class-based agent and create the configuration list for the environment."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 10,
      "metadata": {
        "id": "ntPrZ0nm1-qP"
      },
      "outputs": [],
      "source": [
        "awright_agent = AwrightAgent(\"Connect-4 Agent\")\n",
        "\n",
        "players = [\n",
        "    {\n",
        "        \"algo\": awright_agent.act,\n",
        "        \"name\": \"AWright Agent (Class)\",\n",
        "        \"player\": +1,\n",
        "        \"args\": {}\n",
        "    },\n",
        "    {\n",
        "        \"algo\": act_random,\n",
        "        \"name\": \"Random Agent (Function)\",\n",
        "        \"player\": -1,\n",
        "        \"args\": {}\n",
        "    }\n",
        "]"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "qhtUce6P1-qP"
      },
      "source": [
        "Run the game"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 13,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 501
        },
        "id": "xxSsl-Aq1-qP",
        "outputId": "c8ac615e-da4b-4692-a48b-ae1619899bb4"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "AWright Agent (Class) took a total of 24.979 seconds\n",
            "Random Agent (Function) took a total of 0.0 seconds\n",
            "The winner is AWright Agent (Class) (1)\n",
            "Turns Taken: 7\n"
          ]
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 640x480 with 1 Axes>"
            ],
            "image/png": "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\n"
          },
          "metadata": {}
        }
      ],
      "source": [
        "\n",
        "result,final_board,all_boards = truly_dynamic_environment(players, size=(6,7), visual = True)\n",
        "\n",
        "visualize(final_board)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "8NiDYbSr1-qP"
      },
      "source": [
        "Slow a replay for analysis."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 12,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 430
        },
        "id": "_WASz3vm1-qP",
        "outputId": "9a889572-9192-46a5-d1ae-748352512d88"
      },
      "outputs": [
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 640x480 with 1 Axes>"
            ],
            "image/png": "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\n"
          },
          "metadata": {}
        }
      ],
      "source": [
        "replay(all_boards)"
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": ".venv",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.12.3"
    },
    "colab": {
      "provenance": []
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
